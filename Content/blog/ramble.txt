I quite like the idea of the P4 language, it seems like it'd make the development of networking devices much easier given that the firmware for such devices would be portable. However, it is still fundamentally tied to the specific device being made as a monolithic firmware blob. That is, there's no way in P4 currently to be able to build a modular data plane platform.
I suspect, as time goes on, people will grow tired of waiting for their device manufacturer to come up with the firmware implementation for some feature they want. (I feel this myself with Ubiquiti tbh!) And fair play to them, there's absolutely no reason why these two parties should be intrinsically tied. In fact, there's no real reason why the device manufacturer can't just worry about their data plane part of the contract, expose any accelerators on that data plane in an abstract fashion (e.g. crypto primitives for VPN use cases for example, but it could be any accelerator really), and then allow small, modular data plane "applications" to be installed into that data plane. Then it's just up to the control plane to coordinate with that data plane how to link those small applications together to form a fully fledged data path/pipeline. Taking a step back, let's detach any knowledge of data planes from networking. Let's intead consider a data plane an "accelerated, preconfigured transform over a stream of data". Data comes in, data flows out. Using that logic, you could consider your GPU a data plane converting vertices, indices, and whatever else into pixels. That is fundamentally a data plane as per this definition. So what's the control plane? Well, Vulkan (or an equivalent API). And you can see how, given my background, this is very relevant. Vulkan uses shaders as those "data plane applications" that are linked together to form a graphics or compute pipeline, but why is it only GPUs for which we're applying this concept? I propose a layered system where I generalise this concept over any data plane, yes with a view to apply it to the networking space, but also to enable the creation of a vast array of applications that could be sitting on a network, or anywhere else really. This would look like (with some acroynms for the codenames that are living in my head):
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         
SL = defines an IR which can be used to define those data plane applications. This is essentially a modular P4, but generalised to allow parsers, deparsers, and also any other packet morph operation using the accelerators (defined as extensions in this IR specification). The IR is expected to generalise over those accelerators (e.g. conditionally using special instructions depending on whether that accelerator is available), but assumes no knowledge of the actual configuration of those accelerators. That is, similar to Vulkan, you're expected to assign descriptors to those accelerators or other structures using a control plane API. This is essentially our SPIR-V stand-in. It is my hope that eventually this would be an abstract parallel hetrogeneous compute API (think HVM2), but for this specific scenario I'm focusing on network parsers, control, and deparsers. Again, basically a P4-like language that can make reference to other programs (to facilitate that linking) and accelerators defined using abstract extensions through descriptors configured by the control plane API.
AP = defines a control plane API (similar to Vulkan, although I do prefer the COM style of programming) that configures every element of the secure processor implementing SL. Essentially, its main responsibility is to configure the data plane to run a pipeline made up of lots of SL programs (and configure data flow between them - think a "dataflow graph" wherein you could configure the links between those programs using a node editor thing). For example you could configure a NAT program, which then links into a VPN program, or whatever else. It is possible that either at this layer or some microcode within the processor (depending on the security concerns) that some processing of the IR into a device-specific assembly language would be needed.
AF = defines a modular software platform that is built atop AP, to allow applications to be installed consisting of capabilities made up from SL programs as well as other components such as a small CPU/software component running within some sandbox e.g. WASM. It is possible that this could feed AP access up to the AF application software in a secure enough fashion that the CPU side of the application doesn't need security scrutiny unto itself, but that would rely on SL and AP being bulletproof enough to allow that.

AP and AF would be defined using DC, an API programming model that essentially defines "actors" for which code is generated to facilitate sandbox communication (e.g. C ABI, which may forward to a network-based implementation again using generated code). An SDK would be defined atop those actors, possibly using code generation as well.

Essentially, I want a device where, on its own, it just has a dumb chip that reads Ethernet frames and only does things with them in accordance with a bunch of apps that you've installed on that device (which bundle and configure SL programs using AP - AF is the software responsible for facilitating this user experience). Want a VPN? There's an app for that, install it and you can plop it right into your data plane. This fixes a problem I've noticed that most network device manufactuers are quite often pretty terrible at control plane software or otherwise exposing anything other than a very specific set of features that may not reflect or evolve fast enough for the wider market. And if you consider government networking for instance, they'd love this in that they don't have to rely on the device manufacturer to do anything. You essentially just need one vendor to implement a SL chip with an AP driver, and then one vendor (me!) to implement that common software (AF, DC, AP utils) that the end device manufacturer (which could be different to the chip manufacturer under this model - think Intel Tofino) can just tie together. Install a driver, then install the software that uses that driver, and finally the user can install the actual device functionality themselves. Separate software development from hardware development.

I post this hoping that one day I get to realise this dream, and so I can point at this to show people just how long I'd been thinking about it if ever I do.
